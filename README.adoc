:toc: macro
:toc-title:
:toclevels: 9

# URI Monitor

image:https://travis-ci.org/jasonkuhrt/uri-monitor.svg?branch=master["Build Status", link="https://travis-ci.org/jasonkuhrt/uri-monitor"]

toc::[]


## Installation

```
yarn add uri-monitor
```

## About

`resource-monitor` (RM) is a simple library that makes it trivial to monitor the results of repeatedly executing an asynchronous action. A canonical example would be monitoring a URL for healthy (e.g. status code 200) responses.

## Example

#### Declarative Request-Retry

We can combine streams together to declaratively create request-retry logic. Inspiration for this example was taken from the imperative request-retry logic in  https://github.com/elastic/elasticsearch-js/blob/master/test/integration/yaml_suite/client_manager.js#L30-L42[this ElasticSearch test suite] which establishes the connectivity with the database before running its test suite.

```js
const runTests = () =>
  Promise.resolve("Your integration test suite here...")

const pingElasticSearch = () =>
  Boolean(Math.round(Math.random()))
    ? Promise.reject(new Error("Foobar network error"))
    : Promise.resolve("OK!")

const pingInterval = 1000
const pingAttempts = 3
const monitor = Monitor.create(pingElasticSearch, pingInterval)
const maxRetries = monitor.drops.takeUntil(monitor.pongs).take(pingAttempts)

monitor
  .pongs
  .takeUntil(maxRetries)
  .take(1)
  .drain()
  .then((result) =>
    result.isResponsive
      ? runTests()
      : Promise.reject(result.data)
  ))
```

## Typical usage

* Start with some function that returns a promise (usually that encapsulates some kind of async IO like network request or file system action)
* Pass this function to `Monitor.create`
* Receive back a stream of events produced by repeatedly invoking the passed function
* There are six possible events representing patterns about the repeated promises. This includes simple "was rejected", "was resolved" as well as deltas "was resolved preceded by was rejected" and vice-versa. See API docs for details about all six.
* Build logic around one or more of the six emitted events using the https://github.com/cujojs/most[`most`] API.

## API

### Monitor.create

```js
Monitor.create(action : () => Promise<A>, intervalMs : number?): Observable<MonitorEvent<A>>
```

* `action` The async action to recurse. The expected usage is that you are somehow pinging the resource you are interested in monitoring.

* `intervalMs` The milliseconds between each `action` invocation. Defaults to `1000`.

* `returns` An observable stream of monitor events. The observable implementation we use is https://github.com/cujojs/most[`most`].



### MonitorEvent<A>

Every invocation of `action` returns a promise, ultimately resolving or rejecting. In the context of a stream of such values, it is useful to have various terms to refer to different state change patterns:

|===
| Event Name | Case
| `pong` | promise resolved
| `drop` | promise rejected
| `check` | case of `pong` or `drop`
| `up` | promise resolved and: previous attempt rejected or was nothing (initial check)
| `down` | promise rejected and: previous attempt resolved or was nothing (initial case)
| `change` | case of `up` or `down`
|===

With this in mind, the type of a `MonitorEvent` is:

```js
type EventType =
  | "pong"
  | "drop"
  | "check"
  | "up"
  | "down"
  | "change"

type MonitorEvent<A> = {
  type : EventType,
  isResponsive : boolean,
  data : A
}
```

And the value of `type` is any of the aforementioned event names.

`result` is the settled value of the promise returned from `action`.

### monitor.<substream>

The observable stream returned by <<create, `create`>> contains **all** events. For example on the first monitor check four events will occur: `check`, `drop | pong`, `change`, `up | down`. But often this is more noise than you want and while it is easy enough to filter the stream (`monitor.filter(...)`) there is an easier way. Each event type has a corresponding property on the main stream whose value is a filtered stream of _just that event_:


##### monitor.checks

##### monitor.pongs

##### monitor.drops

##### monitor.ups

##### monitor.downs

##### monitor.changes
