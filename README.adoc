:toc: macro
:toc-title:
:toclevels: 9

# URI Monitor

image:https://travis-ci.org/jasonkuhrt/uri-monitor.svg?branch=master["Build Status", link="https://travis-ci.org/jasonkuhrt/uri-monitor"]

toc::[]


## Installation

```
yarn add uri-monitor
```

## About

This is a tiny library that makes it trivial to monitor the results of repeatedly executing an asynchronous action. A canonical use-case would be monitoring a URL for healthy (e.g. status code 200) responses but really it could be anything, including actions that don't do any IO but still have something to monitor such random computation. This is a fairly general tool and it interestingly generalizes some things that previously would have been realized with purpose-built code. For example the concept of request-retry can be generally implemented with this library, see the example below.

## Examples

#### Declarative Request-Retry

We can combine streams together to declaratively create request-retry logic. Inspiration for this example was taken from the imperative request-retry logic in  https://github.com/elastic/elasticsearch-js/blob/master/test/integration/yaml_suite/client_manager.js#L30-L42[this ElasticSearch test suite] which establishes the connectivity with the database before running its test suite.

```js
const runTests = () =>
  Promise.resolve("Your integration test suite here...")

const pingElasticSearch = () =>
  Boolean(Math.round(Math.random()))
    ? Promise.reject(new Error("Foobar network error"))
    : Promise.resolve("OK!")

const pingInterval = 1000
const pingAttempts = 3
const monitor = Monitor.create(pingElasticSearch, pingInterval)
const maxRetries = monitor.downs.takeUntil(monitor.ups).take(pingAttempts)

monitor
  .ups
  .take(1)
  .takeUntil(maxRetries)
  .drain()
  .then((result) =>
    result.isResponsive
      ? runTests()
      : Promise.reject(result.data)
  ))
```

## API

### Types

#### MonitorEvent

```js
type MonitorEvent<A> = {
  isResponsive: boolean,
  isResponsiveChanged: boolean,
  data: A | null
  error: Error | null
}
```

A monitor event represents the result of an action invocation. The type variable `A` represents the action's resolution type.

`isResponsive` indicates if the action is resolving while `isResponsiveChanged` indicates if that state is different than the previous event. For the first check wherein there is no such previous event `isResponsiveChanged` is considered to be `true`.

You can think of `isResponsive` as being your health indicator while `isResponsiveChanged` as being your alert to when crashing or recovery occurs. `isResponsiveChanged` is technically a convenience that you could calculate yourself but seeing as its often needed and that its calculation requires state it seems worthwhile.

### .create

```js
Monitor.create(action: () => Promise<A>, intervalMs: number?) => Observable<MonitorEvent<A>>
```

* `action` The async action to recurse. This could be anything: HTTP requests, pure calculation, file system checks...

* `intervalMs` The milliseconds between each `action` invocation. Defaults to `1000`.

* `returns` An observable stream of `MonitorEvent`. The observable implementation we use is https://github.com/cujojs/most[`most`].

### Sub-streams

There are several additional streams pre-filtered on monitor instances that provide a convenient way to consume just a subset of events without any additional code/work from you. You can see these being used in the example.

##### #ups

Stream of events where `isResponsive` is `true`.

##### #downs

Stream of events where `isResponsive` is `false`.

##### #rises

Stream of events where `isResponsive` is `true` and `isResponsiveChanged` is `true`.

##### #falls

Stream of events where `isResponsive` is `false` and `isResponsiveChanged` is `true`.

##### #changes

Stream of events where `isResponsiveChanged` is `true`.
